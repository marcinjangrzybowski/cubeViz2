
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE PartialTypeSignatures #-}

module Syntax where



-- hcomp {x.A.ℓ} {x.A} {~ i ∨ i}
-- (λ { j (i = i0) → x
--    ; j (i = i1)
--        → hcomp {x.A.ℓ} {x.A} {~ j ∨ j ∨ k}
--          (λ { k₁ (j = i0) → q (~ (~ k))
--             ; k₁ (j = i1) → r k₁
--             ; k₁ ((~ k) = i0) → r (j ∧ k₁)
--             })
--          (q (j ∨ k))
--    })
-- (hcomp {x.A.ℓ} {x.A} {(~ i ∨ i) ∨ ~ k}
--  (λ { j ((~ i ∨ i) = i1)
--         → (λ { (i = i0) → x ; (i = i1) → q (k ∧ j) }) _
--     ; j (k = i0)
--         → outS {x.A.ℓ} {x.A} {~ i ∨ i}
--           {λ { (i = i0) → x ; (i = i1) → q i0 }}
--           (inS {x.A.ℓ} {x.A} {~ i ∨ i} (p i))
--     })
--  (p i))|]

data IExpr =
   Min IExpr IExpr |
   Max IExpr IExpr |
   Dim Bool Int |
   Neg IExpr
   deriving Show

type Partial = [(IExpr , Expr)]

data Expr =
  HComp Partial Expr
  | Var String Int [IExpr]
  deriving Show
