{-# LANGUAGE TemplateHaskell #-}

{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE PartialTypeSignatures #-}
import Text.RawString.QQ
import Data.List
import qualified Data.Map as M
import qualified Data.Either as E
import Data.Maybe


import Data.Bifunctor
import Data.Either.Utils

import qualified Text.Parsec as PC
import Text.ParserCombinators.Parsec
import Text.ParserCombinators.Parsec.Error
import qualified Text.Parsec.Prim as PP
import Text.ParserCombinators.Parsec.Pos
import qualified Text.ParserCombinators.Parsec.Token as P
import Text.ParserCombinators.Parsec.Language

import Syntax

assoc :: String
assoc = [r|Context:
i     : I
k     : I
r     : _≡_ {x.A.ℓ} {x.A} z w
q     : _≡_ {x.A.ℓ} {x.A} y z
p     : _≡_ {x.A.ℓ} {x.A} x y
w     : x.A   (not in scope)
z     : x.A   (not in scope)
y     : x.A   (not in scope)
x     : x.A   (not in scope)
x.A   : Type x.A.ℓ   (not in scope)
x.A.ℓ : Level   (not in scope)

Goal:
x.A

Boundary:
k = i0 ⊢ hcomp {x.A.ℓ} {x.A} {~ i ∨ i}
         (λ { j (i = i0) → x
            ; j (i = i1)
                → hcomp {x.A.ℓ} {x.A} {~ j ∨ j}
                  (Cubical.Foundations.Prelude..extendedlambda0 {x.A.ℓ} {x.A} {y} {y}
                   {z} {w} (λ _ → y) q r j)
                  (q j)
            })
         (p i)
k = i1 ⊢ hcomp {x.A.ℓ} {x.A} {~ i ∨ i}
         (λ { j (i = i0) → x ; j (i = i1) → r j })
         (hcomp {x.A.ℓ} {x.A} {~ i ∨ i}
          (λ { j (i = i0) → x ; j (i = i1) → q j }) (p i))
i = i0 ⊢ x
i = i1 ⊢ w

Term:
  hcomp {x.A.ℓ} {x.A} {~ i ∨ i}
(λ { j (i = i0) → x
   ; j (i = i1) → w
   })
(hcomp {x.A.ℓ} {x.A} {(~ i ∨ i) ∨ ~ k}
 (λ { j ((~ i ∨ i) = i1) → q
    ; j (k = i0) → z
    })
 (p i))|]

--   hcomp {x.A.ℓ} {x.A} {~ i ∨ i}
-- (λ { j (i = i0) → x
--    ; j (i = i1)
--        → hcomp {x.A.ℓ} {x.A} {~ j ∨ j ∨ k}
--          (λ { k₁ (j = i0) → q (~ (~ k))
--             ; k₁ (j = i1) → r k₁
--             ; k₁ ((~ k) = i0) → r (j ∧ k₁)
--             })
--          (q (j ∨ k))
--    })
-- (hcomp {x.A.ℓ} {x.A} {(~ i ∨ i) ∨ ~ k}
--  (λ { j ((~ i ∨ i) = i1)
--         → (λ { (i = i0) → x ; (i = i1) → q (k ∧ j) }) _
--     ; j (k = i0)
--         → outS {x.A.ℓ} {x.A} {~ i ∨ i}
--           {λ { (i = i0) → x ; (i = i1) → q i0 }}
--           (inS {x.A.ℓ} {x.A} {~ i ∨ i} (p i))
--     })
--  (p i))|]

assoc0 :: String
assoc0 = [r|Term: Context: Goal:|]--zwqContext: qqqq Term: Context:|]
  


data StateInputRaw = StateInputRaw {
      term           :: String
    , context        :: [(String,String)]
  } deriving (Show)


parseRawInput :: Parser StateInputRaw
parseRawInput = return (StateInputRaw "" [])

-- line = many $ noneOf "\n"

sectionHead =
    (choice
       ((map (\s -> try (string (s ++ ":")) )
       ["Context","Goal","Boundary","Term"] )))

section :: Parser (String,String)
section =
  do h <- sectionHead
     b <- (many (notFollowedBy (sectionHead) >> anyChar))
     return (h , b)
     
mkSectionsParser :: Parser (M.Map String String)
mkSectionsParser =
   (pure M.fromList) <*> (many section)
   -- sepEndBy
   --   (sectionHead
   --            >>= (\x -> return (x , "")))
   --   (many (notFollowedBy (sectionHead) >> anyChar))

parseSctns = parse (mkSectionsParser) ""



data Term = Term String
             deriving Show

data Context = Context [(String,Term)] [(String , Maybe Bool)]
                -- deriving Show

instance Show Context where
   show (Context ty dims) =
     "Types:\n" ++ (intercalate "\n" (map (\(nm, Term val) -> nm ++ " : " ++ val) ty)) 
     ++ "\nDimensions:\n" ++ (intercalate "\n" (map (\(nm, _) -> nm ++ " : " ++ "X") dims))

type Goal = Term


type Boundary = [((Int,Bool),Term)]

data Problem = Problem { pContext :: Context
                       , pGoal :: Goal
                       , pBoundary :: Boundary
                       , pTerm :: Maybe Expr }
                -- deriving Show

instance Show Problem where
   show (Problem ctx gl bd tm) =
       "Context:\n\n"
       ++
       (show  ctx)
       ++"\nTerm:\n\n"
       ++(show tm)

ctxDefName =
    do optional (many space)
       name <- manyTill (digit <|> letter <|> (char '.')) space
       manyTill space (char ':')
       return name

addTyToContext :: Context -> String -> Term -> Context
addTyToContext (Context t d) name tm = Context ((name , tm) : t) d

addDimToContext :: Context -> String -> Context
addDimToContext (Context t d) name = Context t ((name , Nothing) : d)
                                       
parseCtxDef :: PC.Parsec String Context ()
parseCtxDef =
    do ctx <- getState
       -- PC.putState (Context (("x", Term "y") : a) b)
       name <- ctxDefName
       content <- many space >> many (notFollowedBy (newline >> ctxDefName) >> anyChar)
       let ty = parseTerm ctx content
       -- PC.putState (Contex
       case (ty , content) of
           (Left _ , _)-> fail ("error while parsing type of " ++ name)
           (Right t , "I") ->
             do PC.putState (addDimToContext ctx name)
                return ()
           (Right t , _) ->
             do PC.putState (addTyToContext ctx name t)
                return ()

       
    -- do name <- (many _)
    --    return (Context defs [])

parseCtxSection :: PC.Parsec String Context Context
parseCtxSection =
    do defs <- (many parseCtxDef)
       ctx <- getState
       return ctx

parseBoundarySection :: Context -> Parser Boundary
parseBoundarySection c = return []

termParser :: PC.Parsec String Context Term
termParser =
   do t <- many anyChar
      return (Term t)

oms = optional (many space)

discardImplicit = do oms
                     char '{'
                     (many1 (notFollowedBy (char '}') >> anyChar))
                     char '}'
                     return ()

mbBetween :: PC.Parsec String Context a -> PC.Parsec String Context a 
mbBetween p = (try (between (oms >> (char '(')) (oms >> char ')') p)) <|> (try p)

iExprVar :: PC.Parsec String Context IExpr
iExprVar = do oms
              many1 (letter <|> digit)
              return (Dim False 0)

iExprMin :: PC.Parsec String Context IExpr
iExprMin = do oms
              iExprP
              oms
              char '∧'
              oms
              iExprP
              return (Dim False 0)

iExprMax :: PC.Parsec String Context IExpr
iExprMax = do oms
              iExprP
              oms
              char '∨'
              oms
              iExprP
              return (Dim False 0)

iExprNeg :: PC.Parsec String Context IExpr
iExprNeg = do oms
              char '~'
              oms
              iExprP
              return (Dim False 0)

iExprP :: PC.Parsec String Context IExpr
iExprP = do (choice (map (\x -> try (mbBetween x))
                    [ iExprVar , iExprMax , iExprMin , iExprNeg

                    ]))
            return (Dim False 0)

            -- letter , digit , char '~' , char '∨' , char '∧'
            --         , char '(' , char ')', space
            
faceP :: PC.Parsec String Context IExpr
faceP =
  do char '('
     e <- iExprP
     oms
     (try (string "= i0)") <|> (try (string "= i1)")))
     return (e)

partialPCase :: PC.Parsec String Context (IExpr , Expr)
partialPCase =
  do oms
     letter
     oms
     iE <- faceP
     oms
     char '→'
     e <- exprParser
     return (iE , e)

partialP :: PC.Parsec String Context Partial
partialP = do oms
              string "λ {"
              -- (many (notFollowedBy (char '}') >> anyChar))
              oms
              cs <- sepBy partialPCase (char ';')
              oms
              char '}'
              return cs

hcompP :: PC.Parsec String Context Expr
hcompP = do oms
            string "hcomp"
            discardImplicit
            discardImplicit
            discardImplicit
            si <- (mbBetween partialP)
            oms
            lid <- (mbBetween exprParser)
            return (HComp si lid)



varP :: PC.Parsec String Context Expr
varP = do
          -- oms
          h <- many1 (digit <|> letter <|> (char '.'))
          -- space
          oms
          tail <- sepBy (many1 ( letter)) (try space)
          -- tail <- sepBy (iExprP) (try space)
          return (Var h 0 [])

exprParser :: PC.Parsec String Context Expr
exprParser = oms >>
             (
              (try (mbBetween hcompP))                
              <|>
              (try (mbBetween varP)) 

             )
                  


parseExpr :: Context -> String -> Either ParseError Expr
parseExpr c s = runParser (
                do x <- exprParser  
                   eof
                   return x) c "" s

parseTerm :: Context -> String -> Either ParseError Term
parseTerm c s = runParser termParser c "" s 

-- liftRightMaybe :: Either a (Maybe b) -> Maybe (Either a b)
-- liftRightMaybe (Right Nothing) = Nothing
-- liftRightMaybe (Right (Just x)) = Just $ Right x
-- liftRightMaybe (Left x) = Just $ Left x
-- {-# INLINE liftRightMaybe #-}

unliftRightMaybe :: Maybe (Either a b) -> Either a (Maybe b)
unliftRightMaybe Nothing = (Right Nothing)
unliftRightMaybe (Just (Right x)) = (Right (Just x)) 
unliftRightMaybe (Just (Left x)) = (Left x) 

eitherFlat :: Either a (Either a b) -> Either a b
eitherFlat = either Left (either Left Right)

  
-- parseProblem :: String -> Either _ _
parseProblem rawProblem =
  do scns <- parseSctns rawProblem
     ctx <- runParser parseCtxSection (Context [] [])  "" (fromMaybe "" (M.lookup "Context:" scns))
     gl <- (maybe (Left (
                          newErrorMessage
                         (Message "No Goal section present in input!")
                          (initialPos "")
                        )) id
                    $ (fmap (parseTerm ctx) (M.lookup "Term:" scns)))
     bnd <- parse (parseBoundarySection ctx) (fromMaybe "" (M.lookup "Boundary:" scns)) ""
     tm <- unliftRightMaybe (fmap (parseExpr ctx) (M.lookup "Term:" scns))
     return (Problem ctx gl bnd tm)
     
     
     

main :: IO ()
main = putStrLn (show (parseProblem assoc))
